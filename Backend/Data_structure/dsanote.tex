\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}

\title{Data Structures and Algorithms}
\author{}
\date{}

\begin{document}

\maketitle

\section{Data Structures}

\subsection{Arrays}
\begin{itemize}
    \item \textbf{Definition}: A collection of elements identified by index or key.
    \item \textbf{Types}: Static (fixed size) and Dynamic (resizable).
    \item \textbf{Operations}: Insertion, Deletion, Access (O(1) for access by index).
\end{itemize}

\subsection{Linked Lists}
\begin{itemize}
    \item \textbf{Definition}: A linear collection of elements called nodes, where each node points to the next.
    \item \textbf{Types}: Singly Linked List, Doubly Linked List, Circular Linked List.
    \item \textbf{Operations}: Insertion, Deletion (O(1) if the node is known), Traversal (O(n)).
\end{itemize}

\subsection{Stacks}
\begin{itemize}
    \item \textbf{Definition}: A linear data structure that follows the Last In First Out (LIFO) principle.
    \item \textbf{Operations}: Push (insert), Pop (remove), Peek (top element).
\end{itemize}

\subsection{Queues}
\begin{itemize}
    \item \textbf{Definition}: A linear data structure that follows the First In First Out (FIFO) principle.
    \item \textbf{Types}: Simple Queue, Circular Queue, Priority Queue, Deque.
    \item \textbf{Operations}: Enqueue (insert), Dequeue (remove), Peek (front element).
\end{itemize}

\subsection{Hash Tables}
\begin{itemize}
    \item \textbf{Definition}: A data structure that stores key-value pairs for efficient retrieval.
    \item \textbf{Operations}: Insertion, Deletion, Search (average O(1)).
\end{itemize}

\subsection{Trees}
\begin{itemize}
    \item \textbf{Definition}: A hierarchical data structure with a root node and child nodes forming a parent-child relationship.
    \item \textbf{Types}: Binary Tree, Binary Search Tree (BST), AVL Tree, Red-Black Tree, B-Trees, Heaps.
    \item \textbf{Operations}: Insertion, Deletion, Traversal (Inorder, Preorder, Postorder).
\end{itemize}

\subsection{Graphs}
\begin{itemize}
    \item \textbf{Definition}: A collection of nodes (vertices) connected by edges.
    \item \textbf{Types}: Directed, Undirected, Weighted, Unweighted.
    \item \textbf{Representations}: Adjacency Matrix, Adjacency List.
    \item \textbf{Operations}: Traversal (DFS, BFS), Shortest Path (Dijkstra’s, Bellman-Ford), Minimum Spanning Tree (Kruskal’s, Prim’s).
\end{itemize}

\section{Algorithms}

\subsection{Sorting Algorithms}
\begin{itemize}
    \item \textbf{Bubble Sort}: Simple but inefficient. $O(n^2)$.
    \item \textbf{Selection Sort}: Selects the minimum element and swaps. $O(n^2)$.
    \item \textbf{Insertion Sort}: Builds the final sorted array one item at a time. $O(n^2)$.
    \item \textbf{Merge Sort}: Divide and conquer approach. $O(n \log n)$.
    \item \textbf{Quick Sort}: Divide and conquer approach, with a pivot element. Average $O(n \log n)$.
    \item \textbf{Heap Sort}: Utilizes a binary heap data structure. $O(n \log n)$.
\end{itemize}

\subsection{Searching Algorithms}
\begin{itemize}
    \item \textbf{Linear Search}: Sequentially checks each element. $O(n)$.
    \item \textbf{Binary Search}: Requires sorted array, divides the array in half. $O(\log n)$.
\end{itemize}

\subsection{Dynamic Programming}
\begin{itemize}
    \item \textbf{Definition}: Solves complex problems by breaking them down into simpler subproblems and storing the results of subproblems to avoid redundant computing.
    \item \textbf{Examples}: Fibonacci Sequence, Knapsack Problem, Longest Common Subsequence.
\end{itemize}

\subsection{Greedy Algorithms}
\begin{itemize}
    \item \textbf{Definition}: Builds up a solution piece by piece, always choosing the next piece that offers the most immediate benefit.
    \item \textbf{Examples}: Coin Change Problem, Activity Selection, Huffman Coding.
\end{itemize}

\subsection{Divide and Conquer}
\begin{itemize}
    \item \textbf{Definition}: Breaks a problem into smaller subproblems, solves them independently, and combines their solutions to solve the original problem.
    \item \textbf{Examples}: Merge Sort, Quick Sort, Binary Search.
\end{itemize}

\subsection{Backtracking}
\begin{itemize}
    \item \textbf{Definition}: Builds a solution incrementally and removes those solutions that fail to satisfy the constraints of the problem.
    \item \textbf{Examples}: N-Queens Problem, Sudoku Solver, Hamiltonian Path.
\end{itemize}

\subsection{Graph Algorithms}
\begin{itemize}
    \item \textbf{Depth First Search (DFS)}: Explores as far as possible along each branch before backtracking. $O(V + E)$.
    \item \textbf{Breadth First Search (BFS)}: Explores all neighbors at the present depth before moving on to nodes at the next depth level. $O(V + E)$.
    \item \textbf{Dijkstra’s Algorithm}: Finds the shortest path from a source node to all other nodes in a weighted graph. $O(V^2)$ or $O(E + V \log V)$ with a priority queue.
    \item \textbf{Bellman-Ford Algorithm}: Computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph. $O(VE)$.
    \item \textbf{Kruskal’s Algorithm}: Finds the minimum spanning tree for a connected, weighted graph. $O(E \log E)$.
    \item \textbf{Prim’s Algorithm}: Finds the minimum spanning tree for a connected, weighted graph. $O(V^2)$ or $O(E + V \log V)$ with a priority queue.
\end{itemize}

\section{Additional Concepts}

\subsection{Big O Notation}
\begin{itemize}
    \item \textbf{Definition}: Describes the upper bound of the time complexity or space complexity of an algorithm.
    \item \textbf{Common Complexities}: $O(1)$, $O(\log n)$, $O(n)$, $O(n \log n)$, $O(n^2)$, $O(2^n)$, $O(n!)$.
\end{itemize}

\subsection{Recursion}
\begin{itemize}
    \item \textbf{Definition}: A function calls itself as a subroutine.
    \item \textbf{Base Case and Recursive Case}: Essential to prevent infinite loops.
\end{itemize}

\subsection{Amortized Analysis}
\begin{itemize}
    \item \textbf{Definition}: Average time per operation over a sequence of operations, spread out over time.
\end{itemize}

\subsection{Space Complexity}
\begin{itemize}
    \item \textbf{Definition}: The amount of memory an algorithm needs to run to completion.
\end{itemize}
\section{Linear Data Structures}

A linear data structure is a type of data structure in which elements are arranged sequentially, and each element is connected to its previous and next elements. Because of this arrangement, linear data structures are easy to implement and understand.

\subsection{Types of Linear Data Structures}

\subsubsection{Arrays}
\begin{itemize}
    \item \textbf{Definition}: A collection of elements identified by index or key.
    \item \textbf{Operations}: Insertion, deletion, access.
    \item \textbf{Example}: An array of integers: $[1, 2, 3, 4, 5]$.
\end{itemize}

\subsubsection{Linked Lists}
\begin{itemize}
    \item \textbf{Definition}: A collection of nodes where each node contains a data part and a reference (or link) to the next node in the sequence.
    \item \textbf{Types}: Singly linked list, doubly linked list, circular linked list.
    \item \textbf{Example}: A singly linked list with three nodes containing values 1, 2, and 3:
    \begin{verbatim}
    [1] -> [2] -> [3] -> NULL
    \end{verbatim}
\end{itemize}

\subsubsection{Stacks}
\begin{itemize}
    \item \textbf{Definition}: A linear data structure that follows the Last In First Out (LIFO) principle.
    \item \textbf{Operations}: Push (insert), pop (remove), peek (view top element).
    \item \textbf{Example}: A stack of books where you can only take the top book off the stack.
\end{itemize}

\subsubsection{Queues}
\begin{itemize}
    \item \textbf{Definition}: A linear data structure that follows the First In First Out (FIFO) principle.
    \item \textbf{Types}: Simple queue, circular queue, priority queue, deque.
    \item \textbf{Operations}: Enqueue (insert), dequeue (remove), peek (view front element).
    \item \textbf{Example}: A line of people waiting to buy tickets where the first person in line is the first to buy a ticket.
\end{itemize}

\section{Concepts of LIFO and FIFO}

\subsection{LIFO (Last In First Out)}

LIFO is a principle where the last element added to a structure is the first one to be removed. This principle is primarily used in stacks.

\begin{itemize}
    \item \textbf{Example}: Think of a stack of plates. You can only take the top plate off the stack, and the last plate added is the first one to be removed.
\end{itemize}

\begin{verbatim}
Stack:
Top -> Plate 3
       Plate 2
       Plate 1
\end{verbatim}

\begin{itemize}
    \item \textbf{Push}: Adding a plate to the stack (Push Plate 4).
    \item \textbf{Pop}: Removing the top plate from the stack (Pop Plate 4).
\end{itemize}

\subsection{FIFO (First In First Out)}

FIFO is a principle where the first element added to a structure is the first one to be removed. This principle is primarily used in queues.

\begin{itemize}
    \item \textbf{Example}: Think of a queue of people at a ticket counter. The person who arrives first gets served first.
\end{itemize}

\begin{verbatim}
Queue:
Front -> Person 1
         Person 2
         Person 3 -> Rear
\end{verbatim}

\begin{itemize}
    \item \textbf{Enqueue}: Adding a person to the end of the queue (Enqueue Person 4).
    \item \textbf{Dequeue}: Removing the person at the front of the queue (Dequeue Person 1).
\end{itemize}

\section{Examples in Code}

\subsection{Stack (LIFO)}

\begin{lstlisting}[language=Python, caption=Stack implementation using a list]
# Stack implementation using a list
stack = []

# Push operation
stack.append(1)
stack.append(2)
stack.append(3)

print("Stack after pushes:", stack)

# Pop operation
top_element = stack.pop()
print("Popped element:", top_element)
print("Stack after pop:", stack)
\end{lstlisting}

\textbf{Output}:
\begin{verbatim}
Stack after pushes: [1, 2, 3]
Popped element: 3
Stack after pop: [1, 2]
\end{verbatim}

\subsection{Queue (FIFO)}

\begin{lstlisting}[language=Python, caption=Queue implementation using a list]
# Queue implementation using a list
from collections import deque

queue = deque()

# Enqueue operation
queue.append(1)
queue.append(2)
queue.append(3)

print("Queue after enqueues:", list(queue))

# Dequeue operation
front_element = queue.popleft()
print("Dequeued element:", front_element)
print("Queue after dequeue:", list(queue))
\end{lstlisting}

\textbf{Output}:
\begin{verbatim}
Queue after enqueues: [1, 2, 3]
Dequeued element: 1
Queue after dequeue: [2, 3]
\end{verbatim}
\section{Non-Linear Data Structures}

A non-linear data structure is a type of data structure where elements are not arranged sequentially. Instead, they are arranged in a hierarchical manner, making it possible to represent more complex relationships between elements. Non-linear data structures are suitable for representing data with multiple relationships.

\subsection{Types of Non-Linear Data Structures}

\subsubsection{Trees}
\begin{itemize}
    \item \textbf{Definition}: A tree is a hierarchical structure consisting of nodes, with a single node designated as the root, and every other node being connected by edges.
    \item \textbf{Types}:
    \begin{itemize}
        \item \textbf{Binary Tree}: Each node has at most two children, referred to as the left child and the right child.
        \item \textbf{Binary Search Tree (BST)}: A binary tree where for each node, the left subtree has nodes with values less than the node’s value, and the right subtree has nodes with values greater than the node’s value.
        \item \textbf{AVL Tree}: A self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one for all nodes.
        \item \textbf{Heap}: A complete binary tree where each node is greater than or equal to (or less than or equal to) its children (max heap or min heap).
        \item \textbf{B-Tree}: A balanced tree data structure that maintains sorted data and allows for searches, sequential access, insertions, and deletions in logarithmic time.
    \end{itemize}
    \item \textbf{Example}: 
    \begin{verbatim}
        1
       / \
      2   3
     / \
    4   5
    \end{verbatim}
\end{itemize}

\subsubsection{Graphs}
\begin{itemize}
    \item \textbf{Definition}: A graph is a collection of nodes (or vertices) and edges connecting pairs of nodes. 
    \item \textbf{Types}:
    \begin{itemize}
        \item \textbf{Directed Graph (Digraph)}: A graph where edges have a direction.
        \item \textbf{Undirected Graph}: A graph where edges do not have a direction.
        \item \textbf{Weighted Graph}: A graph where edges have weights.
        \item \textbf{Unweighted Graph}: A graph where edges do not have weights.
        \item \textbf{Cyclic Graph}: A graph that contains at least one cycle.
        \item \textbf{Acyclic Graph}: A graph that does not contain any cycles.
    \end{itemize}
    \item \textbf{Example}: 
    \begin{verbatim}
        A -- B
        |  / |
        | /  |
        C -- D
    \end{verbatim}
\end{itemize}

\section{Differences between Linear and Non-Linear Data Structures}

\begin{table}[h!]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Criteria} & \textbf{Linear Data Structures} & \textbf{Non-Linear Data Structures} \\
        \hline
        \textbf{Definition} & Elements are arranged sequentially. & Elements are arranged hierarchically. \\
        \hline
        \textbf{Examples} & Arrays, Linked Lists, Stacks, Queues. & Trees, Graphs. \\
        \hline
        \textbf{Memory Utilization} & Generally requires more memory for storage. & Requires less memory due to hierarchical storage. \\
        \hline
        \textbf{Complexity} & Easier to implement and understand. & More complex due to hierarchical relationships. \\
        \hline
        \textbf{Traversal} & Linear traversal: sequential access. & Non-linear traversal: hierarchical or graph-based access. \\
        \hline
        \textbf{Data Relationship} & Single level of relationship. & Multiple levels of relationships. \\
        \hline
        \textbf{Use Cases} & Simple applications: basic data storage, queue management. & Complex applications: hierarchical data, network models. \\
        \hline
    \end{tabular}
    \caption{Differences between Linear and Non-Linear Data Structures}
    \label{tab:linear_vs_nonlinear}
\end{table}

\section{Examples in Code}

\subsection{Binary Tree}

\begin{lstlisting}[language=Python, caption=Binary Tree Node implementation]
class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

# Create root
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
\end{lstlisting}

\subsection{Graph}

\begin{lstlisting}[language=Python, caption=Graph implementation using adjacency list]
class Graph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, u, v):
        if u in self.graph:
            self.graph[u].append(v)
        else:
            self.graph[u] = [v]

    def print_graph(self):
        for node in self.graph:
            print(node, "->", " -> ".join([str(i) for i in self.graph[node]]))

# Create a graph
g = Graph()
g.add_edge(0, 1)
g.add_edge(0, 4)
g.add_edge(1, 2)
g.add_edge(1, 3)
g.add_edge(1, 4)
g.add_edge(2, 3)
g.add_edge(3, 4)

g.print_graph()
\end{lstlisting}

\textbf{Output}:
\begin{verbatim}
0 -> 1 -> 4
1 -> 2 -> 3 -> 4
2 -> 3
3 -> 4
\end{verbatim}
\section{Introduction to Algorithms}

An algorithm is a step-by-step procedure or set of rules designed for solving a specific problem or accomplishing a particular task. It provides a systematic approach to solving problems efficiently and is fundamental in various fields of study, especially in computer science and mathematics.

\subsection{Characteristics of Algorithms}

\begin{itemize}
    \item \textbf{Well-defined}: Algorithms must have clear and unambiguous steps that can be precisely followed.
    \item \textbf{Input}: They take zero or more inputs which are processed to produce output.
    \item \textbf{Output}: They produce at least one output, which is the result of the computation.
    \item \textbf{Finite}: Algorithms must terminate after a finite number of steps.
    \item \textbf{Effective}: Every step in an algorithm must be executable using available resources within a reasonable amount of time.
\end{itemize}

\subsection{Examples of Algorithms}

\begin{itemize}
    \item \textbf{Sorting Algorithms}: Bubble Sort, Merge Sort, Quick Sort, etc., used to arrange data in a specific order.
    \item \textbf{Searching Algorithms}: Linear Search, Binary Search, used to find elements within a dataset.
    \item \textbf{Graph Algorithms}: Depth-First Search (DFS), Breadth-First Search (BFS), used to traverse graphs and find paths.
    \item \textbf{Mathematical Algorithms}: Euclid's Algorithm for finding the greatest common divisor (GCD).
\end{itemize}

\subsection{Importance of Algorithms}

Algorithms are essential for several reasons:

\begin{itemize}
    \item They provide a systematic way to solve problems efficiently.
    \item They form the foundation of computational thinking and computer science.
    \item Well-designed algorithms can optimize performance and scalability.
    \item They enable computers to process large amounts of data and perform complex tasks effectively.
\end{itemize}

In essence, algorithms play a crucial role in modern computing, enabling the development of software solutions and efficient problem-solving techniques.
\section*{Array Operations}

Array operations refer to various actions or manipulations that can be performed on arrays. Here are some common array operations:

\begin{itemize}
    \item \textbf{Accessing Elements}: Retrieving elements from an array using their indices.
    
    \item \textbf{Insertion}: Adding new elements to an array. Depending on the language and implementation, this can involve inserting at the beginning, end, or a specific position within the array.
    
    \item \textbf{Deletion}: Removing elements from an array. Similar to insertion, deletion can occur at various positions in the array.
    
    \item \textbf{Updating}: Modifying the value of an existing element in the array.
    
    \item \textbf{Traversal}: Iterating through all elements in the array to perform a specific operation on each element.
    
    \item \textbf{Sorting}: Arranging the elements of the array in a particular order, such as ascending or descending.
    
    \item \textbf{Searching}: Finding the position or presence of a specific element within the array.
    
    \item \textbf{Merging}: Combining two or more arrays into a single array.
    
    \item \textbf{Splitting}: Dividing an array into smaller arrays based on certain criteria, such as size or value.
    
    \item \textbf{Copying}: Creating a duplicate or a subset of an array.
    
    \item \textbf{Resizing}: Adjusting the size of the array dynamically, if supported by the programming language or data structure.
    
    \item \textbf{Concatenation}: Combining two arrays end-to-end to form a new array.
\end{itemize}

These operations are fundamental to manipulating and managing data efficiently using arrays in various programming languages and applications. Each operation may have different complexities and considerations depending on the language and underlying implementation details.




\end{document}
